#!/usr/bin/env bash
set -euo pipefail
source "$(dirname "$0")/_common.sh"
_need docker
_need git

# Get repository root path (works in both main repo and worktrees)
REPO_ROOT="$(git rev-parse --show-toplevel)"

# Get original repository name, even when in a worktree
COMMON_GIT_DIR="$(git rev-parse --git-common-dir)"

# Fix repository name detection for both main repo and worktrees
if [[ "$COMMON_GIT_DIR" == ".git" ]]; then
  # We're in the main repo, use REPO_ROOT directly
  REPO_NAME="$(basename "$REPO_ROOT")"
else
  # We're in a worktree, follow the symlink
  MAIN_REPO_PATH="$(dirname "$COMMON_GIT_DIR")"
  # Get the actual repo name, not "."
  REPO_NAME="$(basename "$(realpath "$MAIN_REPO_PATH")")"
fi

# For logging
_green "Using repository name: $REPO_NAME from git common dir: $COMMON_GIT_DIR"

# Parse arguments
YES_FLAG=false
FORCE_FLAG=false
TARGET_BRANCH=""
CUSTOM_REGION=""

while [[ $# -gt 0 ]]; do
  case "$1" in
    -y|--yes)
      YES_FLAG=true
      shift
      ;;
    -f|--force)
      FORCE_FLAG=true
      shift
      ;;
    --region=*)
      CUSTOM_REGION="${1#*=}"
      shift
      ;;
    -h|--help)
      echo "Usage: ai-up [OPTIONS] [BRANCH_NAME]"
      echo
      echo "Options:"
      echo "  -y, --yes          Automatically answer yes to all prompts"
      echo "  -f, --force        Force rebuild of container even if it exists"
      echo "  --region=REGION    Override default AWS region"
      echo "  -h, --help         Show this help message"
      echo
      exit 0
      ;;
    -*)
      _red "Unknown option: $1"
      exit 1
      ;;
    *)
      TARGET_BRANCH="$1"
      shift
      break
      ;;
  esac
done

# If no branch name provided after option, use current branch
if [[ -z "$TARGET_BRANCH" ]]; then
  TARGET_BRANCH="$(git symbolic-ref --quiet --short HEAD)"
  [[ -z "$TARGET_BRANCH" ]] && _die "Not on a branch; either specify a branch or checkout one"
fi
  
# Check if the branch exists
if ! git show-ref --verify --quiet "refs/heads/$TARGET_BRANCH"; then
  if $YES_FLAG; then
    _green "Automatically creating branch '$TARGET_BRANCH'"
    git branch "$TARGET_BRANCH"
    _green "Branch '$TARGET_BRANCH' created. Branch location: $WT_ROOT/$REPO_NAME/$TARGET_BRANCH"
  else
    # Branch doesn't exist, offer to create it
    read -p "Branch '$TARGET_BRANCH' doesn't exist. Create it? [y/N] " -n 1 -r
    echo
    if [[ $REPLY =~ ^[Yy]$ ]]; then
      git branch "$TARGET_BRANCH"
      _green "Branch '$TARGET_BRANCH' created. Branch location: $WT_ROOT/$REPO_NAME/$TARGET_BRANCH"
    else
      _die "Branch '$TARGET_BRANCH' doesn't exist"
    fi
  fi
fi

# Determine if we're in a worktree
IS_WORKTREE=false
CURRENT_DIR="$(pwd)"
WORKTREE_LIST="$(git worktree list --porcelain)"

# Check if current directory is a worktree
if echo "$WORKTREE_LIST" | grep -q "worktree $CURRENT_DIR"; then
  IS_WORKTREE=true
  CURRENT_BRANCH="$(git symbolic-ref --quiet --short HEAD)"
  
  # If we're in a worktree and target is different branch, warn user
  if [[ "$CURRENT_BRANCH" != "$TARGET_BRANCH" ]]; then
    _red "Warning: You're in worktree for branch '$CURRENT_BRANCH' but targeting '$TARGET_BRANCH'"
    if $YES_FLAG; then
      _green "Automatically continuing due to --yes flag"
    else
      read -p "Continue? [y/N] " -n 1 -r
      echo
      if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        exit 0
      fi
    fi
  fi
fi

# Set up worktree path and container name
WORKTREE_DIR="$WT_ROOT/$REPO_NAME/$TARGET_BRANCH"
# Include repo name in container name to avoid collisions between different repos
CTR="ai-${REPO_NAME}-${TARGET_BRANCH//\//-}"

# Check if container already exists and is running
if docker ps --format "{{.Names}}" | grep -q "^$CTR$"; then
  if [[ "$FORCE_FLAG" == "true" ]]; then
    _green "Force rebuilding container $CTR for $TARGET_BRANCH"
    docker stop "$CTR"
    docker rm "$CTR"
  else
    _green "Container $CTR is already running for $TARGET_BRANCH"
    _green "Worktree is at $WORKTREE_DIR"
    _yellow "Use --force to rebuild the container with latest changes"
    exit 0
  fi
fi

# Check if container exists but is stopped
if docker ps -a --format "{{.Names}}" | grep -q "^$CTR$"; then
  if [[ "$FORCE_FLAG" == "true" ]]; then
    _green "Force rebuilding stopped container $CTR for $TARGET_BRANCH"
    docker rm "$CTR"
  else
    _green "Starting existing container $CTR for $TARGET_BRANCH"
    docker start "$CTR"
    exit 0
  fi
fi

# Ensure worktree exists
if [[ ! -d "$WORKTREE_DIR" ]]; then
  _green "Creating worktree for $TARGET_BRANCH at $WORKTREE_DIR"
  
  # Check if this is the main branch and we're in the main worktree
  MAIN_BRANCH=$(git symbolic-ref --short refs/remotes/origin/HEAD 2>/dev/null | sed 's#^origin/##' || echo "master")
  CURRENT_BRANCH="$(git symbolic-ref --quiet --short HEAD)"
  
  if [[ "$TARGET_BRANCH" == "$MAIN_BRANCH" && "$CURRENT_BRANCH" == "$TARGET_BRANCH" ]]; then
    _yellow "Warning: Attempting to create a worktree for the same branch ($TARGET_BRANCH) that we're currently on."
    _green "Will use current directory as the worktree instead of creating a new one."
    # Use the current directory as the worktree
    WORKTREE_DIR="$REPO_ROOT"
  else
    # Try to add the worktree, handle errors
    if ! git worktree add "$WORKTREE_DIR" "$TARGET_BRANCH" 2>/dev/null; then
      # Check if worktree already exists elsewhere
      EXISTING_WORKTREE=$(git worktree list | grep "$TARGET_BRANCH" | awk '{print $1}')
      
      if [[ -n "$EXISTING_WORKTREE" ]]; then
        _yellow "Worktree for $TARGET_BRANCH already exists at $EXISTING_WORKTREE"
        _green "Using existing worktree location"
        WORKTREE_DIR="$EXISTING_WORKTREE"
      else
        _red "Failed to create worktree. Trying alternate method..."
        # Try to prune any stale worktrees
        git worktree prune
        # Try again
        git worktree add "$WORKTREE_DIR" "$TARGET_BRANCH" || _die "Could not create worktree for $TARGET_BRANCH"
      fi
    fi
  fi
fi

# Credential handling is now done directly in the container by reading from mounted host files
# No need to precompute IMDS_URL anymore

# Check if credential file exists and show info message
if [[ -f "$HOME/.ai/env/awsvault_url" ]]; then
  _green "Found AWS credential server information at $HOME/.ai/env/awsvault_url"
  _green "Container will dynamically read and transform this URL at runtime"
elif [[ -f "$HOME/.ai/awsvault_url" ]]; then
  _green "Found AWS credential server information at $HOME/.ai/awsvault_url"
  _green "Container will dynamically read and transform this URL at runtime"
else
  _yellow "Warning: AWS credential server URL not found."
  _yellow "Run ai-awsvault <profile> first for immediate availability."
fi

# compose env file
ENV_FILE="$WORKTREE_DIR/.env.compose"

# Use custom region if specified
if [[ -n "$CUSTOM_REGION" ]]; then
  AWS_REGION="$CUSTOM_REGION"
fi

cat >"$ENV_FILE" <<EOF
WORKTREE=$WORKTREE_DIR
HOME=$HOME
AI_CONTAINER_NAME=$CTR
CLAUDE_CODE_USE_BEDROCK=$CLAUDE_CODE_USE_BEDROCK
AWS_REGION=$AWS_REGION
AI_BRANCH=$TARGET_BRANCH
CPU_LIMIT=$CPU_LIMIT
MEM_LIMIT=$MEM_LIMIT
EOF

# Start container
# Check if docker compose subcommand exists, otherwise use docker-compose
# Also set the build context to the repository root where scripts/container is located
if docker compose version &>/dev/null; then
  cd "$REPO_ROOT" && docker compose --env-file "$ENV_FILE" -f "$REPO_ROOT/.ai/docker-compose.yml" up --build -d dev
else
  # Use docker-compose for older versions
  cd "$REPO_ROOT" && docker-compose --env-file "$ENV_FILE" -f "$REPO_ROOT/.ai/docker-compose.yml" up --build -d dev
fi

echo "$CTR" > "$WORKTREE_DIR/.ai-container"
_green "‚úî Container $CTR running for $TARGET_BRANCH"
_green "üìÅ Branch location: $WORKTREE_DIR"